<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostLink Prover & Mint Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js"></script>
    <style>
        body { font-family: monospace; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f0f0f0; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        textarea { width: 100%; font-family: monospace; border: 1px solid #ccc; padding: 10px; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #000; color: white; border: none; border-radius: 4px; margin-top: 10px; margin-right: 10px;}
        button:hover { background-color: #333; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        #status { margin-top: 20px; font-weight: bold; }
        pre { background: #eee; padding: 10px; overflow-x: auto; }
        .section { margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 20px; }
        .step { margin-bottom: 10px; padding: 10px; background: #f9f9f9; border-left: 3px solid #ccc; }
        .warning { color: red; font-weight: bold; }
        .info-box { background: #e8f4f8; padding: 10px; border-radius: 4px; margin-top: 10px; border: 1px solid #bce8f1; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GhostLink Demo</h1>

        <!-- Wallet Section -->
        <div class="section">
            <h3>1. Wallet Connection</h3>
            <button id="connectBtn">Connect Wallet</button>
            <span id="walletAddress">Not connected</span>
        </div>

        <!-- Deploy Section -->
        <div class="section">
            <h3>2. Deploy Contracts (REQUIRED)</h3>
            <p class="warning">âš ï¸ Contract logic changed. Please redeploy!</p>

            <div class="step">
                <h4>Step A: Verifier Address</h4>
                <p>Using RISC Zero Official Pre-deployed Verifier</p>
                <select id="networkSelect" style="width: 100%; padding: 5px; margin-top: 5px; margin-bottom: 10px;">
                    <option value="sepolia-router">Sepolia - Router (æ¨è) - 0x925d8331ddc0a1F0d96E68CF073DFE1d92b69187</option>
                    <option value="sepolia-groth16">Sepolia - Groth16 (ç›´æ¥) - 0x2a098988600d87650Fb061FfAff08B97149Fa84D</option>
                    <option value="mainnet-router">Mainnet - Router (æ¨è) - 0x8EaB2D97Dfce405A1692a21b3ff3A172d593D319</option>
                    <option value="mainnet-groth16">Mainnet - Groth16 (ç›´æ¥) - 0x54aCE3ED46529B4d4F3770C8Bad5dDC48717B9bF</option>
                </select>
                <input type="text" id="verifierAddress" placeholder="Verifier Address" value="0x925d8331ddc0a1F0d96E68CF073DFE1d92b69187" style="width: 100%; padding: 5px; margin-top: 5px;" readonly>
                <p style="font-size: 11px; color: #666; margin-top: 5px;">
                    <strong>Routerï¼ˆæ¨èï¼‰</strong>: è‡ªåŠ¨è·¯ç”±åˆ°æ­£ç¡®çš„ verifierï¼Œæ”¯æŒæœªæ¥ç‰ˆæœ¬æ›´æ–°<br>
                    <strong>Groth16ï¼ˆç›´æ¥ï¼‰</strong>: ç›´æ¥ä½¿ç”¨ Groth16 verifierï¼Œè·³è¿‡è·¯ç”±å±‚
                </p>
            </div>

            <div class="step">
                <h4>Step B: Deploy SBT</h4>
                <p id="bytecodeStatus" style="font-size: 12px; color: #666;">Status: Waiting for artifact...</p>
                <label>Image ID (Hex):</label>
                <input type="text" id="deployImageId" placeholder="Paste Image ID here (from Step 3)..." style="width: 100%; padding: 5px; margin-bottom: 10px;">
                <button id="deploySBTBtn">Deploy SBT</button>
                <div id="deployStatus"></div>
            </div>
        </div>

        <!-- Prover Section -->
        <div class="section">
            <h3>3. Generate ZK Proof (Off-chain)</h3>
            <p>Backend Service: <code>http://localhost:3000/prove</code></p>
            <p class="info-box" style="margin-bottom: 10px;">
                <strong>âš ï¸ æ³¨æ„ï¼š</strong>è¯·ç¡®ä¿åç«¯æœåŠ¡æ­£åœ¨è¿è¡Œï¼<br>
                è¿è¡Œå‘½ä»¤ï¼š<code>cd host && cargo run</code>
            </p>
            <textarea id="jsonInput" rows="5" placeholder='Enter GitHub user JSON data...'></textarea>
            <p style="font-size: 12px; color: #666; margin-top: 5px;">
                Example: <code>{"id": 12345, "login": "test_user", "created_at": "2020-01-01T00:00:00Z", "public_repos": 5}</code>
            </p>
            <button id="loadExampleBtn" style="padding: 5px 10px; font-size: 12px; margin-top: 5px;">Load Example</button>
            <button id="proveBtn">Generate Proof</button>
            <div id="proverStatus"></div>

            <div id="imageIdDisplay" class="info-box" style="display:none;">
                <strong>Current Image ID:</strong> <span id="currentImageId"></span>
                <br>
                <small style="color: #666;">ğŸ‘‰ Copy this ID to "Step B" above and Deploy!</small>
            </div>
        </div>

        <!-- Mint Section -->
        <div class="section">
            <h3>4. Mint SBT (On-chain)</h3>
            <p>Contract Address: <input type="text" id="contractAddress" placeholder="Deploy first, then address will appear here..." style="width: 300px; padding: 5px;"></p>
            <button id="mintBtn" disabled>Mint SBT</button>
            <div id="mintStatus"></div>
        </div>

        <!-- Set Base URI Section -->
        <div class="section">
            <h3>5. Set NFT Metadata (Optional)</h3>
            <p style="font-size: 12px; color: #666;">
                è®¾ç½® Base URI ä»¥åœ¨ MetaMask ä¸­æ˜¾ç¤º NFT å›¾ç‰‡å’Œå…ƒæ•°æ®<br>
                <strong>âš ï¸ é‡è¦ï¼š</strong>MetaMask ä¸æ”¯æŒ <code>ipfs://</code> åè®®ï¼Œè¯·ä½¿ç”¨ HTTP ç½‘å…³ URL<br>
                æ ¼å¼ç¤ºä¾‹: <code>https://YOUR_GATEWAY_NAME.mypinata.cloud/ipfs/YOUR_HASH/</code> (Pinata è‡ªå®šä¹‰ç½‘å…³ï¼Œæ¨è)<br>
                æˆ– <code>https://cloudflare-ipfs.com/ipfs/YOUR_HASH/</code> (Cloudflare å…¬å…±ç½‘å…³)<br>
                å¦‚æœè¾“å…¥ <code>ipfs://</code> æ ¼å¼ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è½¬æ¢ä¸º HTTP ç½‘å…³ URL
            </p>
            <p>Contract Address: <input type="text" id="setURIContractAddress" placeholder="Enter contract address..." style="width: 300px; padding: 5px;"></p>
            <input type="text" id="baseURIInput" placeholder="Enter Base URI (e.g., https://ipfs.io/ipfs/QmXXX/)" style="width: 100%; padding: 5px; margin-bottom: 5px;">
            <button id="setBaseURIBtn" disabled>Set Base URI</button>
            <button id="getBaseURIBtn" disabled>Get Current Base URI</button>
            <button id="testMetadataBtn" disabled>Test Metadata JSON</button>
            <div id="baseURIStatus"></div>
            <div class="info-box" style="margin-top: 10px;">
                <strong>ğŸ’¡ æç¤ºï¼š</strong><br>
                1. ä½¿ç”¨ IPFS: ä¸Šä¼ å…ƒæ•°æ® JSON åˆ° IPFSï¼Œä½¿ç”¨æ–‡ä»¶å¤¹ Hash ä½œä¸º Base URI<br>
                2. ä½¿ç”¨ HTTP: åˆ›å»ºå…ƒæ•°æ®æœåŠ¡å™¨ï¼Œè¿”å› JSON æ ¼å¼çš„å…ƒæ•°æ®<br>
                3. æŸ¥çœ‹ <a href="../NFT_METADATA_GUIDE.md" target="_blank">NFT_METADATA_GUIDE.md</a> äº†è§£è¯¦ç»†æ­¥éª¤
            </div>
        </div>

        <!-- Verify & Query Section -->
        <div class="section">
            <h3>6. Verify & Query</h3>
            
            <div class="step">
                <h4>5.1 Check My SBTs</h4>
                <button id="checkMySBTsBtn" disabled>Check My SBTs</button>
                <div id="mySBTsStatus"></div>
                <div id="mySBTsResult" style="display: none; margin-top: 10px;">
                    <h5>Your SBTs:</h5>
                    <div id="mySBTsList"></div>
                </div>
            </div>

            <div class="step">
                <h4>5.2 Verify Address</h4>
                <p>Check if an address owns any GhostLink SBT:</p>
                <input type="text" id="verifyAddressInput" placeholder="Enter address to verify (0x...)" style="width: 100%; padding: 5px; margin-bottom: 5px;">
                <button id="verifyAddressBtn" disabled>Verify Address</button>
                <div id="verifyAddressStatus"></div>
            </div>

            <div class="step">
                <h4>5.3 Check Nullifier</h4>
                <p>Check if a nullifier has been used:</p>
                <input type="text" id="checkNullifierInput" placeholder="Enter nullifier (0x...)" style="width: 100%; padding: 5px; margin-bottom: 5px;">
                <button id="checkNullifierBtn" disabled>Check Nullifier</button>
                <div id="checkNullifierStatus"></div>
            </div>

            <div class="step">
                <h4>5.4 Query Token Info</h4>
                <p>Get token information by tokenId:</p>
                <input type="number" id="tokenIdInput" placeholder="Enter token ID" style="width: 100%; padding: 5px; margin-bottom: 5px;" min="0">
                <button id="queryTokenBtn" disabled>Query Token</button>
                <div id="queryTokenStatus"></div>
            </div>

            <div class="step">
                <h4>5.5 Contract Info</h4>
                <button id="getContractInfoBtn" disabled>Get Contract Info</button>
                <div id="contractInfoStatus"></div>
                <div id="contractInfoResult" style="display: none; margin-top: 10px;">
                    <pre id="contractInfoDisplay"></pre>
                </div>
            </div>
        </div>

        <div id="result" style="display: none;">
            <h4>Proof Data:</h4>
            <pre id="jsonOutput"></pre>
        </div>
    </div>

    <script>
        let proofData = null;
        let provider, signer;
        let userAddress = null;
        let sbtArtifact = null;

        // RISC Zero å®˜æ–¹é¢„ç¼–è¯‘ Verifier åœ°å€
        // RISC Zero Verifier åœ°å€
        // Routerï¼ˆæ¨èï¼‰: è‡ªåŠ¨è·¯ç”±åˆ°æ­£ç¡®çš„ verifierï¼Œæ”¯æŒæœªæ¥ç‰ˆæœ¬
        // Groth16ï¼ˆç›´æ¥ï¼‰: ç›´æ¥ä½¿ç”¨ Groth16 verifier
        const VERIFIER_ADDRESSES = {
            "sepolia-router": "0x925d8331ddc0a1F0d96E68CF073DFE1d92b69187",  // RiscZeroVerifierRouterï¼ˆæ¨èï¼‰
            "sepolia-groth16": "0x2a098988600d87650Fb061FfAff08B97149Fa84D",  // RiscZeroGroth16Verifierï¼ˆç›´æ¥ï¼‰
            "mainnet-router": "0x8EaB2D97Dfce405A1692a21b3ff3A172d593D319",  // RiscZeroVerifierRouterï¼ˆæ¨èï¼‰
            "mainnet-groth16": "0x54aCE3ED46529B4d4F3770C8Bad5dDC48717B9bF"   // RiscZeroGroth16Verifierï¼ˆç›´æ¥ï¼‰
        };

        // æ›´æ–° verifier åœ°å€ï¼ˆå½“é¡µé¢åŠ è½½å®Œæˆåï¼‰
        document.addEventListener('DOMContentLoaded', () => {
            const networkSelect = document.getElementById('networkSelect');
            const verifierAddress = document.getElementById('verifierAddress');
            
            if (networkSelect && verifierAddress) {
                networkSelect.addEventListener('change', (e) => {
                    const network = e.target.value;
                    verifierAddress.value = VERIFIER_ADDRESSES[network];
                });
            }
            
            // åŠ è½½ç¤ºä¾‹ JSON
            const loadExampleBtn = document.getElementById('loadExampleBtn');
            const jsonInput = document.getElementById('jsonInput');
            if (loadExampleBtn && jsonInput) {
                loadExampleBtn.addEventListener('click', () => {
                    const exampleJson = {
                        id: 12345,
                        login: "test_user",
                        created_at: "2020-01-01T00:00:00Z",
                        public_repos: 5
                    };
                    jsonInput.value = JSON.stringify(exampleJson, null, 2);
                });
                // è‡ªåŠ¨åŠ è½½ç¤ºä¾‹
                loadExampleBtn.click();
            }
        });

        async function loadArtifact(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) throw new Error("Artifact not found: " + filename);
                const json = await response.json();
                let bytecode = null;
                if (json.bytecode && typeof json.bytecode === 'object' && json.bytecode.object) {
                    bytecode = json.bytecode.object;
                } else if (typeof json.bytecode === 'string') {
                    bytecode = json.bytecode;
                } else if (json.data && json.data.bytecode && json.data.bytecode.object) {
                    bytecode = json.data.bytecode.object;
                }
                return { abi: json.abi, bytecode: bytecode };
            } catch (e) {
                console.warn(e);
                return null;
            }
        }

        async function loadAllArtifacts() {
            sbtArtifact = await loadArtifact('./GhostLinkSBT.json');
            const statusEl = document.getElementById('bytecodeStatus');
            if (!sbtArtifact) {
                document.getElementById('deployStatus').innerText = "âš ï¸ Missing GhostLinkSBT.json";
                statusEl.innerText = "Status: Missing Artifact";
            } else {
                statusEl.innerHTML = `<span style="color: green;">âœ… Ready to deploy.</span>`;
            }
        }

        document.getElementById('connectBtn').addEventListener('click', async () => {
            if (window.ethereum) {
                try {
                    provider = new ethers.BrowserProvider(window.ethereum);
                    signer = await provider.getSigner();
                    const address = await signer.getAddress();
                    
                    // éªŒè¯åœ°å€æ ¼å¼ï¼ˆç¡®ä¿æ˜¯æœ‰æ•ˆçš„ä»¥å¤ªåŠåœ°å€ï¼‰
                    if (!ethers.isAddress(address)) {
                        throw new Error("Invalid address format: " + address);
                    }
                    
                    // ç¡®ä¿åœ°å€æ ¼å¼æ­£ç¡®ï¼ˆå°å†™ï¼Œå¸¦0xå‰ç¼€ï¼‰
                    userAddress = ethers.getAddress(address); // è¿™ä¼šæ ‡å‡†åŒ–åœ°å€æ ¼å¼
                    
                    console.log("Connected wallet address:", userAddress);
                    console.log("Address length:", userAddress.length, "(should be 42)");
                    
                    document.getElementById('walletAddress').innerText = userAddress;
                    loadAllArtifacts();
                    
                    // æ›´æ–°æŸ¥è¯¢æŒ‰é’®çŠ¶æ€
                    setTimeout(() => {
                        if (typeof updateQueryButtonsState === 'function') {
                            updateQueryButtonsState();
                        }
                    }, 100);
                } catch (e) {
                    console.error("Wallet connection error:", e);
                    alert("Connection failed: " + e.message);
                }
            } else {
                alert("Please install MetaMask!");
            }
        });

        document.getElementById('deploySBTBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('deployStatus');
            const verifierAddr = document.getElementById('verifierAddress').value;
            const imageId = document.getElementById('deployImageId').value;

            if (!signer) return alert("Connect wallet first!");
            if (!sbtArtifact) return alert("SBT artifact not loaded!");
            if (!imageId || imageId.length < 10) return alert("Please enter a valid Image ID!");

            statusDiv.innerText = "Deploying SBT...";

            try {
                const factory = new ethers.ContractFactory(sbtArtifact.abi, sbtArtifact.bytecode, signer);
                const contract = await factory.deploy(verifierAddr, imageId);

                statusDiv.innerText = "Deploying... TX: " + contract.deploymentTransaction().hash;
                await contract.waitForDeployment();
                const addr = await contract.getAddress();

                statusDiv.innerText = "âœ… SBT Deployed at: " + addr;
                document.getElementById('contractAddress').value = addr;
                
                // æ›´æ–°æŸ¥è¯¢æŒ‰é’®çŠ¶æ€
                if (typeof updateQueryButtonsState === 'function') {
                    updateQueryButtonsState();
                }

            } catch (e) {
                console.error(e);
                statusDiv.innerText = "âŒ Error: " + e.message;
            }
        });

        document.getElementById('proveBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('proverStatus');
            const resultDiv = document.getElementById('result');
            const outputPre = document.getElementById('jsonOutput');
            const mintBtn = document.getElementById('mintBtn');
            let json = document.getElementById('jsonInput').value.trim();
            const imageIdDisplay = document.getElementById('imageIdDisplay');
            const currentImageIdSpan = document.getElementById('currentImageId');

            if (!userAddress) {
                alert("Please connect wallet first!");
                return;
            }

            // æ¸…ç†å’ŒéªŒè¯ JSON æ ¼å¼
            try {
                // ç§»é™¤å¯èƒ½çš„ BOM å’Œä¸å¯è§å­—ç¬¦
                json = json.replace(/^\uFEFF/, '').trim();
                
                // å°è¯•è§£æ JSON
                let parsed;
                try {
                    parsed = JSON.parse(json);
                } catch (parseError) {
                    // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                    const errorMsg = parseError.message || 'Invalid JSON format';
                    const position = parseError.message?.match(/position (\d+)/)?.[1];
                    let helpfulMsg = errorMsg;
                    
                    if (position) {
                        const pos = parseInt(position);
                        const lines = json.split('\n');
                        let lineNum = 1;
                        let charCount = 0;
                        for (let i = 0; i < lines.length; i++) {
                            if (charCount + lines[i].length + 1 > pos) {
                                lineNum = i + 1;
                                break;
                            }
                            charCount += lines[i].length + 1;
                        }
                        helpfulMsg = `${errorMsg}\nAt line ${lineNum}, column ${pos - charCount + 1}`;
                    }
                    
                    statusDiv.innerHTML = `âŒ JSON Parse Error: ${helpfulMsg}<br><small>Please check your JSON input. Make sure it's valid JSON format.</small>`;
                    console.error('JSON Parse Error:', parseError);
                    console.error('JSON content:', json);
                    return;
                }
                
                // éªŒè¯å¿…éœ€å­—æ®µ
                if (typeof parsed.id !== 'number') {
                    throw new Error('JSON must contain "id" field (number)');
                }
                if (typeof parsed.login !== 'string') {
                    throw new Error('JSON must contain "login" field (string)');
                }
                if (typeof parsed.created_at !== 'string') {
                    throw new Error('JSON must contain "created_at" field (string)');
                }
                if (typeof parsed.public_repos !== 'number') {
                    throw new Error('JSON must contain "public_repos" field (number)');
                }
                
                // é‡æ–°åºåˆ—åŒ–ä»¥ç¡®ä¿æ ¼å¼æ­£ç¡®
                json = JSON.stringify(parsed);
                
                console.log('Validated JSON:', json);
            } catch (e) {
                statusDiv.innerHTML = `âŒ Validation Error: ${e.message}<br><small>Please check your JSON input</small>`;
                console.error('Validation Error:', e);
                return;
            }

            statusDiv.innerText = "Processing... (Generating ZK Proof)";
            mintBtn.disabled = true;
            resultDiv.style.display = "none";
            imageIdDisplay.style.display = "none";

            try {
                // ç¡®ä¿åœ°å€æ ¼å¼æ­£ç¡®
                if (!userAddress || !ethers.isAddress(userAddress)) {
                    throw new Error("Invalid wallet address. Please reconnect your wallet.");
                }
                
                // æ ‡å‡†åŒ–åœ°å€æ ¼å¼
                const normalizedAddress = ethers.getAddress(userAddress);
                console.log("Sending proof request with recipient:", normalizedAddress);
                
                const response = await fetch('http://localhost:3000/prove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        input_json: json,
                        recipient: normalizedAddress
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();

                if (data.status !== "success") {
                    throw new Error(data.status || "Proof generation failed");
                }

                // éªŒè¯è¿”å›çš„æ•°æ®æ ¼å¼
                console.log("=== Proof Data Validation ===");
                console.log("Receipt hex length:", data.receipt_hex?.length || 0, "chars");
                console.log("Journal hex length:", data.journal_hex?.length || 0, "chars (should be 128)");
                console.log("Nullifier hex length:", data.nullifier_hex?.length || 0, "chars (should be 64)");
                console.log("Image ID hex length:", data.image_id_hex?.length || 0, "chars (should be 64)");
                
                // æ£€æŸ¥ journal æ ¼å¼
                if (data.journal_hex && data.journal_hex.length !== 128) {
                    console.warn("âš ï¸ WARNING: Journal hex length is", data.journal_hex.length, "but should be 128!");
                    console.warn("  Journal hex:", data.journal_hex);
                    console.warn("  This may cause verification to fail!");
                }
                
                // æ£€æŸ¥ nullifier æ ¼å¼
                if (data.nullifier_hex && data.nullifier_hex.length !== 64) {
                    console.warn("âš ï¸ WARNING: Nullifier hex length is", data.nullifier_hex.length, "but should be 64!");
                }

                proofData = data;
                statusDiv.innerText = "âœ… Proof Generated!";
                resultDiv.style.display = "block";
                outputPre.innerText = JSON.stringify(data, null, 2);
                mintBtn.disabled = false;

                if (data.image_id_hex) {
                    const hexId = "0x" + data.image_id_hex;
                    currentImageIdSpan.innerText = hexId;
                    imageIdDisplay.style.display = "block";
                    const deployInput = document.getElementById('deployImageId');
                    if (!deployInput.value) {
                        deployInput.value = hexId;
                    }
                }

            } catch (e) {
                console.error(e);
                statusDiv.innerText = "âŒ Error: " + e.message;
            }
        });

        document.getElementById('mintBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('mintStatus');
            const contractAddr = document.getElementById('contractAddress').value;

            if (!contractAddr) return alert("Enter contract address!");
            if (!signer) return alert("Connect wallet first!");
            if (!proofData) return alert("Generate proof first!");

            statusDiv.innerText = "Preparing transaction...";

            try {
                // å¼ºåˆ¶é‡æ–°è·å–å¹¶éªŒè¯åœ°å€ï¼ˆé˜²æ­¢åœ°å€è¢«é”™è¯¯ä¿®æ”¹ï¼‰
                const currentAddress = await signer.getAddress();
                if (!ethers.isAddress(currentAddress)) {
                    throw new Error(`Invalid address from signer: ${currentAddress}`);
                }
                userAddress = ethers.getAddress(currentAddress); // æ ‡å‡†åŒ–åœ°å€
                
                if (userAddress.length !== 42) {
                    throw new Error(`Invalid address length: ${userAddress.length}, expected 42. Address: ${userAddress}`);
                }
                
                console.log("âœ… Validated address:", userAddress, "Length:", userAddress.length);
                const abi = sbtArtifact ? sbtArtifact.abi : [
                    "function mint(bytes calldata seal, address recipient, bytes32 nullifier) external",
                    "function imageId() external view returns (bytes32)",
                    "function verifier() external view returns (address)",
                    "function nullifiers(bytes32) external view returns (bool)"
                ];

                // åˆ›å»ºåªè¯»åˆçº¦å®ä¾‹ç”¨äºé¢„æ£€æŸ¥
                const readOnlyContract = new ethers.Contract(contractAddr, abi, provider);
                // åˆ›å»ºå¯å†™åˆçº¦å®ä¾‹ç”¨äºäº¤æ˜“
                const contract = new ethers.Contract(contractAddr, abi, signer);

                // éªŒè¯åˆçº¦å‚æ•°ï¼ˆä½¿ç”¨åªè¯»åˆçº¦ï¼‰
                statusDiv.innerText = "Verifying contract parameters...";
                const contractImageId = await readOnlyContract.imageId();
                const proofImageId = "0x" + proofData.image_id_hex;
                
                console.log("Contract Image ID:", contractImageId);
                console.log("Proof Image ID:", proofImageId);
                
                if (contractImageId.toLowerCase() !== proofImageId.toLowerCase()) {
                    throw new Error(`Image ID mismatch!\nContract: ${contractImageId}\nProof: ${proofImageId}\n\nPlease ensure the contract was deployed with the correct Image ID.`);
                }
                console.log("âœ… Image ID matches");

                // å¤„ç† sealï¼šç¡®ä¿æœ‰ 0x å‰ç¼€
                let seal = proofData.receipt_hex;
                if (!seal.startsWith("0x")) {
                    seal = "0x" + seal;
                }
                
                // å¤„ç† nullifierï¼šç¡®ä¿æœ‰ 0x å‰ç¼€ï¼Œä¸”æ ¼å¼æ­£ç¡®
                let nullifier = proofData.nullifier_hex;
                // ç§»é™¤å¯èƒ½å­˜åœ¨çš„ 0x å‰ç¼€
                if (nullifier.startsWith("0x")) {
                    nullifier = nullifier.substring(2);
                }
                // ç¡®ä¿æ˜¯ 64 ä¸ªåå…­è¿›åˆ¶å­—ç¬¦
                if (nullifier.length !== 64) {
                    throw new Error(`Invalid nullifier length: expected 64 hex chars, got ${nullifier.length}. Value: ${nullifier}`);
                }
                // éªŒè¯æ˜¯å¦ä¸ºæœ‰æ•ˆçš„åå…­è¿›åˆ¶
                if (!/^[0-9a-fA-F]{64}$/.test(nullifier)) {
                    throw new Error(`Invalid nullifier format: must be 64 hex characters. Value: ${nullifier}`);
                }
                // æ·»åŠ  0x å‰ç¼€
                nullifier = "0x" + nullifier;

                // éªŒè¯å‚æ•°æ ¼å¼
                if (!seal || seal.length < 10) {
                    throw new Error("Invalid seal format");
                }
                if (!nullifier || nullifier.length !== 66) { // 0x + 64 hex chars
                    throw new Error(`Invalid nullifier format. Expected 66 chars, got ${nullifier.length}: ${nullifier}`);
                }
                
                // è¾“å‡ºéªŒè¯åçš„å‚æ•°ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                console.log("Processed parameters:");
                console.log("  Seal:", seal.substring(0, 20) + "...", "Length:", seal.length);
                console.log("  Nullifier:", nullifier, "Length:", nullifier.length);
                console.log("  Recipient:", userAddress);
                
                // éªŒè¯ seal æ ¼å¼ï¼ˆGroth16 seal åº”è¯¥ä»¥ç‰¹å®šé€‰æ‹©å™¨å¼€å¤´ï¼‰
                console.log("=== Seal Analysis ===");
                console.log("Seal first 10 chars:", seal.substring(0, 10));
                console.log("Seal length:", seal.length, "chars");
                
                // æå– seal çš„é€‰æ‹©å™¨ï¼ˆå‰4ä¸ªå­—èŠ‚ï¼Œå»æ‰0xåæ˜¯8ä¸ªå­—ç¬¦ï¼‰
                const sealSelector = seal.substring(0, 10); // "0x" + 8 hex chars = 10 chars
                console.log("Seal selector (first 4 bytes):", sealSelector);
                console.log("Seal selector hex (without 0x):", seal.substring(2, 10));
                
                // æ£€æŸ¥ seal é•¿åº¦ï¼ˆGroth16 seal åº”è¯¥æ˜¯çº¦ 256-300 å­—èŠ‚ = 512-600 å­—ç¬¦ï¼‰
                const sealByteLength = (seal.length - 2) / 2; // å‡å» "0x"ï¼Œé™¤ä»¥2å¾—åˆ°å­—èŠ‚æ•°
                console.log("Seal byte length:", sealByteLength, "bytes");
                
                if (sealByteLength < 200 || sealByteLength > 400) {
                    console.warn("âš ï¸ Seal length unusual. Groth16 seals are typically 256-300 bytes.");
                }
                
                // éªŒè¯ journal ç¼–ç ï¼ˆç”¨äºè°ƒè¯•ï¼‰
                // åˆçº¦æœŸæœ›ï¼šabi.encode(recipient, nullifier)
                // è¿™ä¼šäº§ç”Ÿ 64 å­—èŠ‚ï¼š12å­—èŠ‚å¡«å…… + 20å­—èŠ‚åœ°å€ + 32å­—èŠ‚nullifier
                try {
                    const expectedJournal = ethers.AbiCoder.defaultAbiCoder().encode(
                        ["address", "bytes32"],
                        [userAddress, nullifier]
                    );
                    const expectedJournalDigest = ethers.sha256(expectedJournal);
                    
                    // è·å–åç«¯è¿”å›çš„ journalï¼ˆå¦‚æœæœ‰ï¼‰
                    const backendJournal = proofData.journal_hex ? ("0x" + proofData.journal_hex) : null;
                    
                    console.log("=== Journal Verification ===");
                    console.log("Expected journal (from contract):", expectedJournal);
                    console.log("Expected journal digest:", expectedJournalDigest);
                    console.log("Backend journal hex:", backendJournal);
                    
                    if (backendJournal) {
                        const backendJournalDigest = ethers.sha256(backendJournal);
                        console.log("Backend journal digest:", backendJournalDigest);
                        console.log("Journal match:", expectedJournal.toLowerCase() === backendJournal.toLowerCase());
                        console.log("Journal digest match:", expectedJournalDigest.toLowerCase() === backendJournalDigest.toLowerCase());
                        
                        if (expectedJournal.toLowerCase() !== backendJournal.toLowerCase()) {
                            console.warn("âš ï¸ WARNING: Journal mismatch!");
                            console.warn("  Expected:", expectedJournal);
                            console.warn("  Backend: ", backendJournal);
                        }
                    }
                    
                    console.log("Journal length:", expectedJournal.length, "bytes (should be 64 bytes = 128 hex chars + 0x)");
                } catch (e) {
                    console.warn("Could not encode journal:", e);
                }
                
                // åœ°å€å·²åœ¨å‡½æ•°å¼€å§‹æ—¶éªŒè¯ï¼Œè¿™é‡Œå†æ¬¡ç¡®è®¤
                console.log("Using address for mint:", userAddress, "Length:", userAddress.length);

                console.log("Mint Parameters:");
                console.log("  Seal length:", seal.length);
                console.log("  Nullifier:", nullifier);
                console.log("  Recipient:", userAddress);
                console.log("  Image ID:", proofImageId);

                // é¢„æ£€æŸ¥ï¼šæ£€æŸ¥ nullifier æ˜¯å¦å·²è¢«ä½¿ç”¨ï¼ˆä½¿ç”¨åªè¯»åˆçº¦ï¼‰
                statusDiv.innerText = "Checking nullifier...";
                try {
                    const nullifierUsed = await readOnlyContract.nullifiers(nullifier);
                    if (nullifierUsed) {
                        throw new Error("This proof has already been used. Please generate a new proof.");
                    }
                    console.log("âœ… Nullifier not used");
                } catch (checkError) {
                    if (checkError.message && checkError.message.includes("already been used")) {
                        throw checkError;
                    }
                    console.warn("Could not check nullifier:", checkError);
                }

                // é¢„æ£€æŸ¥ï¼šä½¿ç”¨ callStatic æ¨¡æ‹Ÿäº¤æ˜“ä»¥è·å–è¯¦ç»†é”™è¯¯
                statusDiv.innerText = "Simulating transaction...";
                
                // éªŒè¯å‚æ•°ç±»å‹å’Œæ ¼å¼
                console.log("Parameter types check:");
                console.log("  seal type:", typeof seal, "is hex:", seal.startsWith("0x"));
                console.log("  userAddress type:", typeof userAddress, "is address:", ethers.isAddress(userAddress));
                console.log("  nullifier type:", typeof nullifier, "is hex:", nullifier.startsWith("0x"));
                
                // ç¡®ä¿ seal æ˜¯æœ‰æ•ˆçš„ bytes
                if (!seal.startsWith("0x")) {
                    throw new Error("Seal must be a hex string starting with 0x");
                }
                
                // å†æ¬¡éªŒè¯ nullifier æ ¼å¼ï¼ˆç¡®ä¿æ²¡æœ‰è¢«ä¿®æ”¹ï¼‰
                if (!nullifier.startsWith("0x") || nullifier.length !== 66) {
                    console.error("Nullifier validation failed:", {
                        value: nullifier,
                        length: nullifier.length,
                        startsWith0x: nullifier.startsWith("0x")
                    });
                    throw new Error(`Nullifier must be a hex string of 66 characters (0x + 64 hex), got: ${nullifier.length}. Value: ${nullifier}`);
                }
                
                // éªŒè¯ nullifier æ˜¯æœ‰æ•ˆçš„ bytes32
                try {
                    // å°è¯•å°† nullifier è½¬æ¢ä¸º bytes32 æ ¼å¼
                    const nullifierBytes = ethers.hexlify(nullifier);
                    if (nullifierBytes.length !== 66) {
                        throw new Error(`Invalid nullifier bytes length: ${nullifierBytes.length}`);
                    }
                    console.log("âœ… Nullifier format validated:", nullifierBytes);
                } catch (e) {
                    console.error("âŒ Nullifier format error:", e);
                    throw new Error(`Invalid nullifier format: ${e.message}. Value: ${nullifier}`);
                }
                
                try {
                    console.log("Calling mint.staticCall with parameters:");
                    console.log("  seal:", seal.substring(0, 20) + "...", "type:", typeof seal);
                    console.log("  userAddress:", userAddress, "type:", typeof userAddress);
                    console.log("  nullifier:", nullifier, "type:", typeof nullifier);
                    
                    await contract.mint.staticCall(seal, userAddress, nullifier);
                    console.log("âœ… Transaction simulation successful");
                } catch (simError) {
                    console.error("Transaction simulation failed:", simError);
                    console.error("Error data:", simError.data);
                    console.error("Error transaction:", simError.transaction);
                    
                    let errorMsg = "Transaction will fail";
                    
                    // å°è¯•è§£æé”™è¯¯ä¿¡æ¯
                    if (simError.reason) {
                        errorMsg = simError.reason;
                    } else if (simError.data) {
                        // æ£€æŸ¥æ˜¯å¦æ˜¯æ ‡å‡†é”™è¯¯ï¼ˆError(string)ï¼‰
                        const errorData = simError.data;
                        if (errorData.length >= 138) {
                            try {
                                // Error(string) é€‰æ‹©å™¨æ˜¯ 0x08c379a0
                                // å¦‚æœé”™è¯¯æ•°æ®ä»¥ 0x08c379a0 å¼€å¤´ï¼Œå°è¯•è§£ç 
                                const reason = ethers.AbiCoder.defaultAbiCoder().decode(
                                    ["string"],
                                    "0x" + errorData.slice(10) // è·³è¿‡é€‰æ‹©å™¨ (4 bytes = 8 hex chars) + offset (32 bytes = 64 hex chars)
                                );
                                if (reason && reason[0]) {
                                    errorMsg = reason[0];
                                    console.log("Decoded error reason:", reason[0]);
                                }
                            } catch (e) {
                                console.warn("Could not decode error reason:", e);
                            }
                        }
                        
                        // å°è¯•è§£ç è‡ªå®šä¹‰é”™è¯¯
                        try {
                            const errorInterface = new ethers.Interface([
                                "error InvalidMint(string message)",
                                "error NotTokenOwner(string message)",
                                "error TokenNotTransferable(string message)",
                                "error ProofVerificationFailed()",
                                "error ImageIdMismatch()",
                                "error NullifierAlreadyUsed()"
                            ]);
                            const decoded = errorInterface.parseError(errorData);
                            if (decoded) {
                                errorMsg = decoded.name + (decoded.args.length > 0 ? ": " + decoded.args[0] : "");
                                console.log("Decoded custom error:", decoded);
                            }
                        } catch (decodeError) {
                            console.warn("Could not decode custom error:", decodeError);
                        }
                        
                        // å¦‚æœé”™è¯¯æ•°æ®æ˜¯ 0xe4ea6542ï¼Œè¿™å¯èƒ½æ˜¯ verifier çš„é”™è¯¯
                        if (errorData.startsWith("0xe4ea6542")) {
                            errorMsg = "âŒ Proof verification failed (0xe4ea6542). This usually means:\n" +
                                      "  1. Seal format is incorrect\n" +
                                      "  2. Image ID doesn't match\n" +
                                      "  3. Journal digest doesn't match\n" +
                                      "  4. Verifier address is wrong";
                            
                            console.error("âš ï¸ Verifier error detected (0xe4ea6542). Detailed check:");
                            console.error("  1. Seal format and length:", seal.length, "chars");
                            console.error("     Seal first 10 chars:", seal.substring(0, 10));
                            console.error("     Seal selector (bytes 0-3):", seal.substring(2, 10));
                            console.error("     Seal byte length:", (seal.length - 2) / 2, "bytes");
                            console.error("  2. Image ID match:", contractImageId.toLowerCase() === proofImageId.toLowerCase());
                            console.error("     Contract Image ID:", contractImageId);
                            console.error("     Proof Image ID:", proofImageId);
                            
                            // è®¡ç®—æœŸæœ›çš„ journal digest
                            try {
                                const expectedJournal = ethers.AbiCoder.defaultAbiCoder().encode(
                                    ["address", "bytes32"],
                                    [userAddress, nullifier]
                                );
                                const expectedDigest = ethers.sha256(expectedJournal);
                                
                                // è·å–åç«¯è¿”å›çš„ journal
                                const backendJournal = proofData.journal_hex ? ("0x" + proofData.journal_hex) : null;
                                
                                console.error("  3. Journal encoding check:");
                                console.error("     Expected journal:", expectedJournal);
                                console.error("     Expected digest:", expectedDigest);
                                
                                if (backendJournal) {
                                    const backendDigest = ethers.sha256(backendJournal);
                                    console.error("     Backend journal:", backendJournal);
                                    console.error("     Backend digest:", backendDigest);
                                    console.error("     Journal match:", expectedJournal.toLowerCase() === backendJournal.toLowerCase());
                                    console.error("     Digest match:", expectedDigest.toLowerCase() === backendDigest.toLowerCase());
                                    
                                    if (expectedJournal.toLowerCase() !== backendJournal.toLowerCase()) {
                                        console.error("     âŒ JOURNAL MISMATCH - This is likely the problem!");
                                    }
                                }
                                
                                console.error("  4. Verifier address:", document.getElementById('verifierAddress').value);
                                console.error("  5. Recipient address:", userAddress);
                                console.error("  6. Nullifier:", nullifier);
                            } catch (e) {
                                console.error("  3. Could not compute journal digest:", e);
                            }
                        }
                    } else if (simError.message) {
                        // å°è¯•ä»æ¶ˆæ¯ä¸­æå–æœ‰ç”¨çš„ä¿¡æ¯
                        if (simError.message.includes("execution reverted")) {
                            errorMsg = "Transaction execution reverted. Check parameters.";
                        } else {
                            errorMsg = simError.message;
                        }
                    }
                    
                    throw new Error(errorMsg);
                }

                statusDiv.innerText = "Estimating gas...";

                // æœ€ç»ˆéªŒè¯å‚æ•°æ ¼å¼ï¼ˆåœ¨è°ƒç”¨å‰å†æ¬¡ç¡®è®¤ï¼‰
                console.log("Final parameter validation before contract call:");
                console.log("  seal:", seal.substring(0, 30) + "...", "starts with 0x:", seal.startsWith("0x"));
                console.log("  userAddress:", userAddress, "is valid:", ethers.isAddress(userAddress));
                console.log("  nullifier:", nullifier, "starts with 0x:", nullifier.startsWith("0x"), "length:", nullifier.length);
                
                // ç¡®ä¿ nullifier æ ¼å¼æ­£ç¡®
                if (!nullifier.startsWith("0x")) {
                    console.error("âŒ CRITICAL: Nullifier missing 0x prefix!");
                    console.error("  Current value:", nullifier);
                    nullifier = "0x" + nullifier;
                    console.log("  Fixed value:", nullifier);
                }
                
                // ä½¿ç”¨ ethers.hexlify ç¡®ä¿æ ¼å¼æ­£ç¡®
                try {
                    nullifier = ethers.hexlify(nullifier);
                    console.log("âœ… Nullifier hexlified:", nullifier);
                } catch (e) {
                    console.error("âŒ Failed to hexlify nullifier:", e);
                    throw new Error(`Invalid nullifier format: ${e.message}. Value: ${nullifier}`);
                }
                
                // è°ƒç”¨ mint å‡½æ•°ï¼šmint(bytes calldata seal, address recipient, bytes32 nullifier)
                // ä½¿ç”¨ estimateGas å…ˆä¼°ç®— gas
                let gasEstimate;
                try {
                    console.log("Estimating gas with parameters:");
                    console.log("  seal length:", seal.length);
                    console.log("  userAddress:", userAddress);
                    console.log("  nullifier:", nullifier);
                    
                    gasEstimate = await contract.mint.estimateGas(seal, userAddress, nullifier);
                    console.log("Estimated gas:", gasEstimate.toString());
                } catch (estimateError) {
                    console.error("Gas estimation failed:", estimateError);
                    console.error("Parameters used:");
                    console.error("  seal:", seal.substring(0, 30) + "...");
                    console.error("  userAddress:", userAddress);
                    console.error("  nullifier:", nullifier, "type:", typeof nullifier);
                    
                    // å¦‚æœä¼°ç®—å¤±è´¥ï¼Œå°è¯•ä» staticCall çš„é”™è¯¯ä¸­è·å–ä¿¡æ¯
                    let errorMsg = "Gas estimation failed";
                    
                    if (estimateError.reason) {
                        errorMsg = estimateError.reason;
                    } else if (estimateError.data) {
                        errorMsg = "Transaction will revert. Check console for details.";
                    } else if (estimateError.message) {
                        errorMsg = estimateError.message;
                    }
                    
                    throw new Error(errorMsg);
                }

                statusDiv.innerText = "Sending transaction...";

                console.log("Sending transaction with parameters:");
                console.log("  seal:", seal.substring(0, 30) + "...");
                console.log("  userAddress:", userAddress);
                console.log("  nullifier:", nullifier);

                const tx = await contract.mint(seal, userAddress, nullifier, { 
                    gasLimit: gasEstimate * BigInt(2)  // ä½¿ç”¨ä¼°ç®—å€¼çš„ 2 å€ä½œä¸ºå®‰å…¨è¾¹ç•Œ
                });
                
                statusDiv.innerText = "Transaction sent: " + tx.hash + "\nWaiting for confirmation...";

                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    statusDiv.innerText = "âœ… Minted Successfully!\nTX: " + tx.hash;
                } else {
                    throw new Error("Transaction failed");
                }

            } catch (e) {
                console.error("Mint Error Details:", e);
                console.error("Error object:", JSON.stringify(e, Object.getOwnPropertyNames(e)));
                
                let errorMsg = e.message || "Unknown error";
                let helpfulTips = "";
                
                // å°è¯•è§£ææ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
                if (e.reason) {
                    errorMsg = e.reason;
                } else if (e.data) {
                    errorMsg = "Transaction reverted. Check console for details.";
                }
                
                // æ ¹æ®é”™è¯¯ç±»å‹æä¾›å¸®åŠ©æç¤º
                if (errorMsg.includes("Image ID") || errorMsg.includes("imageId")) {
                    helpfulTips = "<br><strong>ğŸ’¡ Tip:</strong> Ensure the contract was deployed with the same Image ID as the proof.";
                } else if (errorMsg.includes("already been used") || errorMsg.includes("nullifier")) {
                    helpfulTips = "<br><strong>ğŸ’¡ Tip:</strong> Generate a new proof with different data.";
                } else if (errorMsg.includes("sender") || errorMsg.includes("recipient")) {
                    helpfulTips = "<br><strong>ğŸ’¡ Tip:</strong> Ensure you're using the same wallet that generated the proof.";
                } else if (errorMsg.includes("Gas") || errorMsg.includes("estimation")) {
                    helpfulTips = "<br><strong>ğŸ’¡ Tip:</strong> Check console (F12) for detailed error. Common issues: Image ID mismatch, nullifier already used, or invalid proof.";
                }
                
                statusDiv.innerHTML = `âŒ Mint Error: ${errorMsg}${helpfulTips}<br><small>Check browser console (F12) for full details</small>`;
            }
        });

        // ==================== éªŒè¯å’ŒæŸ¥è¯¢åŠŸèƒ½ ====================

        // è·å–åˆçº¦å®ä¾‹çš„è¾…åŠ©å‡½æ•°
        function getContractInstance() {
            const contractAddr = document.getElementById('contractAddress').value;
            if (!contractAddr) {
                throw new Error("Please enter contract address first!");
            }
            if (!provider) {
                throw new Error("Please connect wallet first!");
            }

            const abi = sbtArtifact ? sbtArtifact.abi : [
                "function balanceOf(address owner) external view returns (uint256)",
                "function ownerOf(uint256 tokenId) external view returns (address)",
                "function tokenURI(uint256 tokenId) external view returns (string)",
                "function nullifiers(bytes32) external view returns (bool)",
                "function imageId() external view returns (bytes32)",
                "function verifier() external view returns (address)",
                "function name() external view returns (string)",
                "function symbol() external view returns (string)",
                "event Minted(address indexed recipient, uint256 indexed tokenId, bytes32 nullifier)"
            ];

            return new ethers.Contract(contractAddr, abi, provider);
        }

        // 5.1 æ£€æŸ¥æˆ‘çš„ SBTs
        document.getElementById('checkMySBTsBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('mySBTsStatus');
            const resultDiv = document.getElementById('mySBTsResult');
            const listDiv = document.getElementById('mySBTsList');

            if (!userAddress) {
                statusDiv.innerText = "âŒ Please connect wallet first!";
                return;
            }

            statusDiv.innerText = "Checking...";

            try {
                const contract = getContractInstance();
                const balance = await contract.balanceOf(userAddress);
                const balanceNum = Number(balance);

                if (balanceNum === 0) {
                    statusDiv.innerHTML = "â„¹ï¸ You don't own any GhostLink SBTs yet.";
                    resultDiv.style.display = "none";
                    return;
                }

                statusDiv.innerHTML = `âœ… Found ${balanceNum} SBT(s)`;

                // ç”±äº ERC721 æ²¡æœ‰ç›´æ¥è·å–æ‰€æœ‰ token çš„æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦éå†
                // è¿™é‡Œæˆ‘ä»¬å°è¯•ä» tokenId 0 å¼€å§‹æŸ¥æ‰¾
                const tokens = [];
                let foundCount = 0;
                const maxCheck = 1000; // æœ€å¤šæ£€æŸ¥ 1000 ä¸ª tokenId

                for (let i = 0; i < maxCheck && foundCount < balanceNum; i++) {
                    try {
                        const owner = await contract.ownerOf(i);
                        if (owner.toLowerCase() === userAddress.toLowerCase()) {
                            tokens.push(i);
                            foundCount++;
                        }
                    } catch (e) {
                        // Token doesn't exist, continue
                    }
                }

                if (tokens.length > 0) {
                    let html = `<table style="width: 100%; border-collapse: collapse; margin-top: 10px;">`;
                    html += `<tr style="background: #f0f0f0;"><th style="padding: 8px; text-align: left;">Token ID</th><th style="padding: 8px; text-align: left;">Owner</th><th style="padding: 8px; text-align: left;">Token URI</th></tr>`;
                    
                    for (const tokenId of tokens) {
                        try {
                            const owner = await contract.ownerOf(tokenId);
                            let tokenURI = "N/A";
                            try {
                                tokenURI = await contract.tokenURI(tokenId);
                            } catch (e) {
                                // Token URI not set
                            }
                            html += `<tr><td style="padding: 8px; border: 1px solid #ddd;">${tokenId}</td><td style="padding: 8px; border: 1px solid #ddd;">${owner}</td><td style="padding: 8px; border: 1px solid #ddd;">${tokenURI}</td></tr>`;
                        } catch (e) {
                            console.error(`Error fetching token ${tokenId}:`, e);
                        }
                    }
                    html += `</table>`;
                    listDiv.innerHTML = html;
                    resultDiv.style.display = "block";
                } else {
                    statusDiv.innerHTML = `âš ï¸ Found ${balanceNum} SBT(s) but couldn't retrieve token IDs.`;
                    resultDiv.style.display = "none";
                }

            } catch (e) {
                console.error("Check My SBTs Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
                resultDiv.style.display = "none";
            }
        });

        // 5.2 éªŒè¯åœ°å€
        document.getElementById('verifyAddressBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('verifyAddressStatus');
            const addressInput = document.getElementById('verifyAddressInput').value.trim();

            if (!addressInput) {
                statusDiv.innerText = "âŒ Please enter an address!";
                return;
            }

            if (!ethers.isAddress(addressInput)) {
                statusDiv.innerText = "âŒ Invalid address format!";
                return;
            }

            statusDiv.innerText = "Verifying...";

            try {
                const contract = getContractInstance();
                const balance = await contract.balanceOf(addressInput);
                const balanceNum = Number(balance);

                if (balanceNum > 0) {
                    statusDiv.innerHTML = `âœ… <strong>Verified!</strong><br>` +
                                        `Address <code>${addressInput}</code> owns <strong>${balanceNum}</strong> GhostLink SBT(s).`;
                } else {
                    statusDiv.innerHTML = `âŒ <strong>Not verified.</strong><br>` +
                                        `Address <code>${addressInput}</code> does not own any GhostLink SBTs.`;
                }

            } catch (e) {
                console.error("Verify Address Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
            }
        });

        // 5.3 æ£€æŸ¥ Nullifier
        document.getElementById('checkNullifierBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('checkNullifierStatus');
            let nullifier = document.getElementById('checkNullifierInput').value.trim();

            if (!nullifier) {
                statusDiv.innerText = "âŒ Please enter a nullifier!";
                return;
            }

            // ç¡®ä¿æœ‰ 0x å‰ç¼€
            if (!nullifier.startsWith("0x")) {
                nullifier = "0x" + nullifier;
            }

            // éªŒè¯æ ¼å¼
            if (nullifier.length !== 66) {
                statusDiv.innerText = `âŒ Invalid nullifier format! Expected 66 characters (0x + 64 hex), got ${nullifier.length}`;
                return;
            }

            statusDiv.innerText = "Checking...";

            try {
                const contract = getContractInstance();
                const used = await contract.nullifiers(nullifier);

                if (used) {
                    statusDiv.innerHTML = `âš ï¸ <strong>Nullifier already used!</strong><br>` +
                                        `Nullifier <code>${nullifier}</code> has been used and cannot be used again.`;
                } else {
                    statusDiv.innerHTML = `âœ… <strong>Nullifier available!</strong><br>` +
                                        `Nullifier <code>${nullifier}</code> has not been used yet.`;
                }

            } catch (e) {
                console.error("Check Nullifier Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
            }
        });

        // 5.4 æŸ¥è¯¢ Token ä¿¡æ¯
        document.getElementById('queryTokenBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('queryTokenStatus');
            const tokenId = document.getElementById('tokenIdInput').value;

            if (!tokenId || tokenId === "") {
                statusDiv.innerText = "âŒ Please enter a token ID!";
                return;
            }

            statusDiv.innerText = "Querying...";

            try {
                const contract = getContractInstance();
                const owner = await contract.ownerOf(tokenId);
                let tokenURI = "N/A";
                try {
                    tokenURI = await contract.tokenURI(tokenId);
                } catch (e) {
                    // Token URI not set
                }

                statusDiv.innerHTML = `
                    <div style="background: #f9f9f9; padding: 10px; border-radius: 4px; margin-top: 10px;">
                        <strong>Token ID:</strong> ${tokenId}<br>
                        <strong>Owner:</strong> <code>${owner}</code><br>
                        <strong>Token URI:</strong> ${tokenURI}<br>
                        <strong>Is yours:</strong> ${owner.toLowerCase() === userAddress?.toLowerCase() ? "âœ… Yes" : "âŒ No"}
                    </div>
                `;

            } catch (e) {
                console.error("Query Token Error:", e);
                if (e.message && e.message.includes("nonexistent token")) {
                    statusDiv.innerHTML = `âŒ Token ID ${tokenId} does not exist.`;
                } else {
                    statusDiv.innerHTML = `âŒ Error: ${e.message}`;
                }
            }
        });

        // 5.5 è·å–åˆçº¦ä¿¡æ¯
        document.getElementById('getContractInfoBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('contractInfoStatus');
            const resultDiv = document.getElementById('contractInfoResult');
            const displayDiv = document.getElementById('contractInfoDisplay');

            statusDiv.innerText = "Fetching contract info...";

            try {
                const contract = getContractInstance();
                const contractAddr = document.getElementById('contractAddress').value;

                const [name, symbol, imageId, verifierAddr] = await Promise.all([
                    contract.name(),
                    contract.symbol(),
                    contract.imageId(),
                    contract.verifier()
                ]);

                // å°è¯•è·å–æ€»ä¾›åº”é‡ï¼ˆé€šè¿‡æ£€æŸ¥å¤šä¸ª tokenIdï¼‰
                let totalTokens = 0;
                const maxCheck = 1000;
                for (let i = 0; i < maxCheck; i++) {
                    try {
                        await contract.ownerOf(i);
                        totalTokens = i + 1;
                    } catch (e) {
                        break;
                    }
                }

                const info = {
                    "Contract Address": contractAddr,
                    "Name": name,
                    "Symbol": symbol,
                    "Image ID": imageId,
                    "Verifier Address": verifierAddr,
                    "Total Tokens Minted": totalTokens > 0 ? totalTokens : "Unknown"
                };

                displayDiv.innerText = JSON.stringify(info, null, 2);
                resultDiv.style.display = "block";
                statusDiv.innerHTML = "âœ… Contract info retrieved!";

            } catch (e) {
                console.error("Get Contract Info Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
                resultDiv.style.display = "none";
            }
        });

        // å¯ç”¨/ç¦ç”¨æŸ¥è¯¢æŒ‰é’®
        function updateQueryButtonsState() {
            const contractAddr = document.getElementById('contractAddress').value;
            const hasContract = contractAddr && contractAddr.length > 0;
            const hasWallet = !!userAddress;

            document.getElementById('checkMySBTsBtn').disabled = !hasContract || !hasWallet;
            document.getElementById('verifyAddressBtn').disabled = !hasContract;
            document.getElementById('checkNullifierBtn').disabled = !hasContract;
            document.getElementById('queryTokenBtn').disabled = !hasContract;
            document.getElementById('getContractInfoBtn').disabled = !hasContract;
        }

        // ç›‘å¬åˆçº¦åœ°å€å˜åŒ–
        document.getElementById('contractAddress').addEventListener('input', updateQueryButtonsState);
        
        // ç›‘å¬é’±åŒ…è¿æ¥
        const originalConnectHandler = document.getElementById('connectBtn').onclick;
        document.getElementById('connectBtn').addEventListener('click', () => {
            if (originalConnectHandler) originalConnectHandler();
            setTimeout(updateQueryButtonsState, 500);
        });

        // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
        updateQueryButtonsState();

        // ==================== Base URI è®¾ç½®åŠŸèƒ½ ====================
        
        // ç›‘å¬åˆçº¦åœ°å€è¾“å…¥ï¼Œå¯ç”¨/ç¦ç”¨æŒ‰é’®
        document.getElementById('setURIContractAddress').addEventListener('input', () => {
            const contractAddr = document.getElementById('setURIContractAddress').value.trim();
            const hasContract = contractAddr && ethers.isAddress(contractAddr);
            document.getElementById('setBaseURIBtn').disabled = !hasContract || !signer;
            document.getElementById('getBaseURIBtn').disabled = !hasContract || !provider;
            document.getElementById('testMetadataBtn').disabled = !hasContract || !provider;
        });

        // è½¬æ¢ JSON ä¸­çš„ ipfs:// å›¾ç‰‡ URL ä¸º HTTP URL
        function convertImageUrlInMetadata(metadata) {
            if (!metadata || !metadata.image) return metadata;
            
            let imageUrl = metadata.image;
            
            // å¦‚æœæ˜¯ ipfs:// åè®®ï¼Œè½¬æ¢ä¸º HTTP ç½‘å…³
            if (imageUrl.startsWith('ipfs://')) {
                const hash = imageUrl.replace('ipfs://', '').trim();
                imageUrl = `https://cloudflare-ipfs.com/ipfs/${hash}`;
                metadata.image = imageUrl;
            }
            
            return metadata;
        }

        // æµ‹è¯•å…ƒæ•°æ® JSON
        document.getElementById('testMetadataBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('baseURIStatus');
            const contractAddr = document.getElementById('setURIContractAddress').value.trim();

            if (!contractAddr || !ethers.isAddress(contractAddr)) {
                statusDiv.innerText = "âŒ Please enter a valid contract address!";
                return;
            }

            if (!provider) {
                statusDiv.innerText = "âŒ Please connect wallet first!";
                return;
            }

            try {
                const abi = sbtArtifact ? sbtArtifact.abi : [
                    "function tokenURI(uint256 tokenId) external view returns (string)"
                ];

                const contract = new ethers.Contract(contractAddr, abi, provider);

                statusDiv.innerHTML = "Testing metadata...<br>";

                // å°è¯•è·å– Token 0 çš„ URI
                let tokenURI;
                try {
                    tokenURI = await contract.tokenURI(0);
                } catch (e) {
                    // å¦‚æœ Token 0 ä¸å­˜åœ¨ï¼Œå°è¯• Token 1
                    try {
                        tokenURI = await contract.tokenURI(1);
                    } catch (e2) {
                        throw new Error("No tokens found. Please mint a token first.");
                    }
                }

                if (!tokenURI || tokenURI === "") {
                    throw new Error("Token URI is empty. Please set Base URI first.");
                }

                statusDiv.innerHTML += `Token URI: <code>${tokenURI}</code><br><br>Fetching metadata JSON...`;

                // è·å–å…ƒæ•°æ® JSON
                const response = await fetch(tokenURI);
                if (!response.ok) {
                    throw new Error(`Failed to fetch metadata: HTTP ${response.status}`);
                }

                const metadata = await response.json();
                
                // æ£€æŸ¥å¹¶è½¬æ¢å›¾ç‰‡ URL
                const originalImage = metadata.image;
                const convertedMetadata = convertImageUrlInMetadata(JSON.parse(JSON.stringify(metadata)));

                let resultHtml = `
                    <div style="background: #f9f9f9; padding: 15px; border-radius: 6px; margin-top: 10px; text-align: left;">
                        <h4 style="margin-top: 0;">âœ… Metadata JSON æµ‹è¯•ç»“æœ</h4>
                        <strong>Token URI:</strong> <code>${tokenURI}</code><br><br>
                        
                        <strong>å…ƒæ•°æ®å†…å®¹:</strong><br>
                        <pre style="background: white; padding: 10px; overflow-x: auto; font-size: 12px;">${JSON.stringify(metadata, null, 2)}</pre><br>
                        
                        <strong>å›¾ç‰‡ URL æ£€æŸ¥:</strong><br>
                `;

                if (!metadata.image) {
                    resultHtml += `<span style="color: red;">âŒ ç¼ºå°‘ "image" å­—æ®µ</span><br>`;
                } else {
                    const imageUrl = metadata.image;
                    const isIpfsProtocol = imageUrl.startsWith('ipfs://');
                    const isHttp = imageUrl.startsWith('http://') || imageUrl.startsWith('https://');
                    
                    resultHtml += `<strong>åŸå§‹å›¾ç‰‡ URL:</strong> <code>${imageUrl}</code><br>`;
                    
                    if (isIpfsProtocol) {
                        resultHtml += `<span style="color: orange;">âš ï¸ å›¾ç‰‡ URL ä½¿ç”¨ ipfs:// åè®®ï¼ˆMetaMask ä¸æ”¯æŒï¼‰</span><br>`;
                        resultHtml += `<strong>å»ºè®®çš„ HTTP URL:</strong> <code>${convertedMetadata.image}</code><br>`;
                        resultHtml += `<a href="${convertedMetadata.image}" target="_blank" style="color: blue;">æµ‹è¯•å›¾ç‰‡é“¾æ¥</a><br>`;
                    } else if (isHttp) {
                        resultHtml += `<span style="color: green;">âœ… å›¾ç‰‡ URL æ ¼å¼æ­£ç¡®ï¼ˆHTTP/HTTPSï¼‰</span><br>`;
                        resultHtml += `<a href="${imageUrl}" target="_blank" style="color: blue;">æµ‹è¯•å›¾ç‰‡é“¾æ¥</a><br>`;
                    } else {
                        resultHtml += `<span style="color: red;">âŒ å›¾ç‰‡ URL æ ¼å¼æ— æ•ˆ</span><br>`;
                    }
                }

                resultHtml += `<br><strong>è°ƒè¯•æ­¥éª¤:</strong><br>`;
                resultHtml += `1. ç‚¹å‡»ä¸Šé¢çš„"æµ‹è¯•å›¾ç‰‡é“¾æ¥"æ£€æŸ¥å›¾ç‰‡æ˜¯å¦å¯ä»¥è®¿é—®<br>`;
                resultHtml += `2. å¦‚æœå›¾ç‰‡ URL æ˜¯ ipfs:// æ ¼å¼ï¼Œéœ€è¦æ›´æ–°å…ƒæ•°æ® JSON ä¸­çš„ image å­—æ®µ<br>`;
                resultHtml += `3. åœ¨æµè§ˆå™¨ä¸­ç›´æ¥æ‰“å¼€ Token URI æ£€æŸ¥ JSON å†…å®¹<br>`;
                resultHtml += `4. æ¸…é™¤ MetaMask ç¼“å­˜å¹¶åˆ·æ–°<br>`;
                resultHtml += `</div>`;

                statusDiv.innerHTML = resultHtml;

            } catch (e) {
                console.error("Test Metadata Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}<br><br><small>è¯·ç¡®ä¿ï¼š<br>1. å·² mint è‡³å°‘ä¸€ä¸ª Token<br>2. å·²è®¾ç½® Base URI<br>3. Token URI å¯ä»¥æ­£å¸¸è®¿é—®</small>`;
            }
        });

        // è½¬æ¢ ipfs:// åè®®ä¸º HTTP ç½‘å…³ URL
        function convertIpfsToHttp(uri) {
            if (!uri) return uri;
            
            // å¦‚æœå·²ç»æ˜¯ HTTP/HTTPSï¼Œç›´æ¥è¿”å›
            if (uri.startsWith('http://') || uri.startsWith('https://')) {
                return uri;
            }
            
            // å¦‚æœæ˜¯ ipfs:// åè®®ï¼Œè½¬æ¢ä¸º HTTP ç½‘å…³
            if (uri.startsWith('ipfs://')) {
                // ç§»é™¤ ipfs:// å‰ç¼€
                const hash = uri.replace('ipfs://', '').trim();
                // ä½¿ç”¨ Cloudflare IPFS ç½‘å…³ï¼ˆé€Ÿåº¦å¿«ï¼Œç¨³å®šï¼‰
                return `https://cloudflare-ipfs.com/ipfs/${hash}`;
            }
            
            // å¦‚æœåªæ˜¯ Hashï¼ˆæ²¡æœ‰åè®®å‰ç¼€ï¼‰ï¼Œæ·»åŠ  HTTP ç½‘å…³
            if (/^[Qmb][a-zA-Z0-9]{43,}$/.test(uri) || /^baf[a-z0-9]+$/.test(uri)) {
                // æ£€æŸ¥æ˜¯å¦ä»¥ / ç»“å°¾
                const hash = uri.endsWith('/') ? uri.slice(0, -1) : uri;
                return `https://cloudflare-ipfs.com/ipfs/${hash}/`;
            }
            
            return uri;
        }

        // è®¾ç½® Base URI
        document.getElementById('setBaseURIBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('baseURIStatus');
            const contractAddr = document.getElementById('setURIContractAddress').value.trim();
            let baseURI = document.getElementById('baseURIInput').value.trim();

            if (!contractAddr || !ethers.isAddress(contractAddr)) {
                statusDiv.innerText = "âŒ Please enter a valid contract address!";
                return;
            }

            if (!baseURI) {
                statusDiv.innerText = "âŒ Please enter Base URI!";
                return;
            }

            if (!signer) {
                statusDiv.innerText = "âŒ Please connect wallet first!";
                return;
            }

            try {
                // è‡ªåŠ¨è½¬æ¢ ipfs:// ä¸º HTTP ç½‘å…³
                const originalURI = baseURI;
                baseURI = convertIpfsToHttp(baseURI);
                
                // ç¡®ä¿ä»¥ / ç»“å°¾
                if (!baseURI.endsWith('/')) {
                    baseURI += '/';
                }
                
                // å¦‚æœè½¬æ¢äº†ï¼Œæ˜¾ç¤ºæç¤º
                if (originalURI !== baseURI) {
                    statusDiv.innerHTML = `â„¹ï¸ å·²è‡ªåŠ¨è½¬æ¢ IPFS åè®®ä¸º HTTP ç½‘å…³:<br>åŸå§‹: <code>${originalURI}</code><br>è½¬æ¢å: <code>${baseURI}</code><br><br>ç»§ç»­è®¾ç½®...`;
                }

                const abi = sbtArtifact ? sbtArtifact.abi : [
                    "function setBaseURI(string calldata baseURI) external",
                    "function owner() external view returns (address)"
                ];

                const contract = new ethers.Contract(contractAddr, abi, signer);

                // æ£€æŸ¥æ˜¯å¦æ˜¯ owner
                statusDiv.innerText = "Checking permissions...";
                const owner = await contract.owner();
                const currentAddress = await signer.getAddress();
                
                if (owner.toLowerCase() !== currentAddress.toLowerCase()) {
                    throw new Error("Only contract owner can set Base URI!");
                }

                // è®¾ç½® Base URI
                statusDiv.innerText = "Setting Base URI...";
                const tx = await contract.setBaseURI(baseURI);
                statusDiv.innerText = `Transaction sent: ${tx.hash}\nWaiting for confirmation...`;
                
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    statusDiv.innerHTML = `âœ… Base URI set successfully!<br>TX: ${tx.hash}`;
                    // è‡ªåŠ¨è·å–å¹¶æ˜¾ç¤ºæ–°çš„ Base URI
                    setTimeout(() => {
                        document.getElementById('getBaseURIBtn').click();
                    }, 1000);
                } else {
                    throw new Error("Transaction failed");
                }

            } catch (e) {
                console.error("Set Base URI Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
            }
        });

        // è·å–å½“å‰ Base URI
        document.getElementById('getBaseURIBtn').addEventListener('click', async () => {
            const statusDiv = document.getElementById('baseURIStatus');
            const contractAddr = document.getElementById('setURIContractAddress').value.trim();

            if (!contractAddr || !ethers.isAddress(contractAddr)) {
                statusDiv.innerText = "âŒ Please enter a valid contract address!";
                return;
            }

            if (!provider) {
                statusDiv.innerText = "âŒ Please connect wallet first!";
                return;
            }

            try {
                const abi = sbtArtifact ? sbtArtifact.abi : [
                    "function tokenURI(uint256 tokenId) external view returns (string)"
                ];

                const contract = new ethers.Contract(contractAddr, abi, provider);

                // å°è¯•è·å– tokenURI(0) æ¥æ¨æ–­ Base URI
                statusDiv.innerText = "Fetching Base URI...";
                
                try {
                    const tokenURI0 = await contract.tokenURI(0);
                    if (!tokenURI0 || tokenURI0 === "") {
                        statusDiv.innerHTML = `
                            <strong>Token URI (Token #0):</strong><br>
                            <code>(empty)</code><br><br>
                            <small>Base URI æœªè®¾ç½®ï¼Œè¯·å…ˆè®¾ç½® Base URI</small>
                        `;
                    } else {
                        // å°è¯•è·å–å¹¶æ˜¾ç¤ºå…ƒæ•°æ®é¢„è§ˆ
                        try {
                            const response = await fetch(tokenURI0);
                            if (response.ok) {
                                const metadata = await response.json();
                                statusDiv.innerHTML = `
                                    <strong>Token URI (Token #0):</strong><br>
                                    <code>${tokenURI0}</code><br><br>
                                    <strong>å…ƒæ•°æ®é¢„è§ˆ:</strong><br>
                                    <pre style="background: #f0f0f0; padding: 10px; overflow-x: auto; font-size: 11px;">${JSON.stringify(metadata, null, 2)}</pre><br>
                                    ${metadata.image ? `<strong>å›¾ç‰‡ URL:</strong> <code>${metadata.image}</code><br><a href="${metadata.image}" target="_blank">æµ‹è¯•å›¾ç‰‡</a>` : '<span style="color: red;">âš ï¸ ç¼ºå°‘å›¾ç‰‡ URL</span>'}
                                `;
                            } else {
                                statusDiv.innerHTML = `
                                    <strong>Token URI (Token #0):</strong><br>
                                    <code>${tokenURI0}</code><br><br>
                                    <span style="color: orange;">âš ï¸ æ— æ³•è®¿é—®å…ƒæ•°æ® URLï¼ˆHTTP ${response.status}ï¼‰</span><br>
                                    <small>è¯·æ£€æŸ¥ URL æ˜¯å¦æ­£ç¡®ï¼Œæˆ–ç‚¹å‡»"Test Metadata JSON"æŒ‰é’®è¿›è¡Œè¯¦ç»†æµ‹è¯•</small>
                                `;
                            }
                        } catch (fetchError) {
                            statusDiv.innerHTML = `
                                <strong>Token URI (Token #0):</strong><br>
                                <code>${tokenURI0}</code><br><br>
                                <span style="color: orange;">âš ï¸ æ— æ³•è·å–å…ƒæ•°æ®: ${fetchError.message}</span><br>
                                <small>è¯·ç‚¹å‡»"Test Metadata JSON"æŒ‰é’®è¿›è¡Œè¯¦ç»†æµ‹è¯•</small>
                            `;
                        }
                    }
                } catch (e) {
                    // å¦‚æœ Token 0 ä¸å­˜åœ¨ï¼Œå°è¯•å…¶ä»–æ–¹æ³•
                    statusDiv.innerHTML = `
                        <strong>Base URI Status:</strong><br>
                        <code>Not set or Token #0 doesn't exist</code><br><br>
                        <small>è¯·å…ˆ mint ä¸€ä¸ª Tokenï¼Œç„¶åè®¾ç½® Base URI</small>
                    `;
                }

            } catch (e) {
                console.error("Get Base URI Error:", e);
                statusDiv.innerHTML = `âŒ Error: ${e.message}`;
            }
        });

        // å¦‚æœåˆçº¦åœ°å€è¾“å…¥æ¡†ä¸ºç©ºï¼Œå°è¯•ä½¿ç”¨éƒ¨ç½²çš„åˆçº¦åœ°å€
        document.getElementById('setURIContractAddress').addEventListener('focus', () => {
            const deployAddr = document.getElementById('contractAddress').value.trim();
            if (deployAddr && !document.getElementById('setURIContractAddress').value.trim()) {
                document.getElementById('setURIContractAddress').value = deployAddr;
                document.getElementById('setURIContractAddress').dispatchEvent(new Event('input'));
            }
        });
    </script>
</body>
</html>
