# GhostLink API 集成指导文档

本文档为合作方提供完整的 API 调用指导，包括生成零知识证明和调用智能合约 mint 方法的详细说明。

## 目录

1. [概述](#概述)
2. [API 接口说明](#api-接口说明)
3. [参数格式说明](#参数格式说明)
4. [完整调用流程](#完整调用流程)
5. [代码示例](#代码示例)
6. [错误处理](#错误处理)
7. [常见问题](#常见问题)

---

## 概述

GhostLink 是一个基于 RISC Zero zkVM 的零知识证明系统，用于验证 GitHub 用户身份并铸造 Soulbound Token (SBT)。

### 核心流程

```
1. 前端准备数据 → 2. 调用后端生成证明 → 3. 使用证明调用合约 mint
```

### 关键概念

- **Image ID**: RISC Zero Guest 程序的唯一标识符，合约部署时必须使用
- **Seal**: Groth16 零知识证明（用于链上验证）
- **Journal**: 公开数据，包含 recipient 和 nullifier
- **Nullifier**: 防止重复使用的唯一标识符

---

## API 接口说明

### 1. 生成零知识证明接口

**接口地址**: `POST http://localhost:3000/prove`

**请求头**:
```
Content-Type: application/json
```

**请求体**:
```json
{
 "input_json": "{\"id\":12345,\"login\":\"test_user\",\"created_at\":\"2020-01-01T00:00:00Z\",\"public_repos\":5}",
 "recipient": "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145"
}
```

#### 请求参数说明

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `input_json` | string | 是 | GitHub 用户数据的 JSON 字符串，必须包含以下字段：<br>- `id` (number): GitHub 用户 ID<br>- `login` (string): GitHub 用户名<br>- `created_at` (string): 账户创建时间（ISO 8601 格式）<br>- `public_repos` (number): 公开仓库数量 |
| `recipient` | string | 是 | 以太坊地址（42 字符，包含 0x 前缀），SBT 的接收地址 |

#### 响应格式

**成功响应**:
```json
{
 "status": "success",
 "receipt_hex": "22d5a59a...",
 "journal_hex": "000000000000000000000000534c283d6339183d20c2e7f0fd6522d9e6cd5145e1543551249113046932741cc28f36b4bbcc542233eb5094874072d3167f160a",
 "image_id_hex": "d00386cb676528a694de49cb717b1be87eabe980135d32696aa72d872525a4f5",
 "nullifier_hex": "e1543551249113046932741cc28f36b4bbcc542233eb5094874072d3167f160a"
}
```

**错误响应**:
```json
{
 "status": "错误信息",
 "receipt_hex": "",
 "journal_hex": "",
 "image_id_hex": "",
 "nullifier_hex": ""
}
```

#### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `status` | string | 状态：`"success"` 表示成功，否则为错误信息 |
| `receipt_hex` | string | Groth16 seal 的十六进制字符串（**不包含 0x 前缀**），长度约 500-600 字符 |
| `journal_hex` | string | Journal 的十六进制字符串（**不包含 0x 前缀**），固定 128 字符（64 字节） |
| `image_id_hex` | string | Image ID 的十六进制字符串（**不包含 0x 前缀**），固定 64 字符（32 字节） |
| `nullifier_hex` | string | Nullifier 的十六进制字符串（**不包含 0x 前缀**），固定 64 字符（32 字节） |

---

## 参数格式说明

### 1. input_json 格式要求

**必须字段**:
- `id`: 数字类型，GitHub 用户 ID
- `login`: 字符串类型，GitHub 用户名
- `created_at`: 字符串类型，ISO 8601 格式的时间戳，例如 `"2020-01-01T00:00:00Z"`
- `public_repos`: 数字类型，公开仓库数量

**示例**:
```json
{
 "id": 12345,
 "login": "test_user",
 "created_at": "2020-01-01T00:00:00Z",
 "public_repos": 5
}
```

**注意事项**:
- `input_json` 必须是有效的 JSON 字符串
- 不能包含 BOM 或不可见字符
- 字段类型必须正确

### 2. recipient 地址格式

- 必须以 `0x` 开头
- 总长度为 42 字符（`0x` + 40 个十六进制字符）
- 必须是有效的以太坊地址格式

**示例**: `0x534C283D6339183d20c2e7f0fd6522d9e6CD5145`

### 3. Journal 格式说明

Journal 是 ABI 编码的 `(address, bytes32)` 元组：

```
Journal = abi.encode(address recipient, bytes32 nullifier)
```

**格式结构**:
- 总长度：64 字节（128 个十六进制字符）
- 前 12 字节：`000000000000000000000000`（填充零）
- 接下来 20 字节：recipient 地址（无 0x 前缀，小写）
- 最后 32 字节：nullifier（无 0x 前缀）

**示例**:
```
000000000000000000000000534c283d6339183d20c2e7f0fd6522d9e6cd5145e1543551249113046932741cc28f36b4bbcc542233eb5094874072d3167f160a
```

### 4. Mint 方法参数映射

后端返回的数据需要转换为合约 `mint` 方法的参数：

| 合约参数 | 类型 | 来源 | 格式说明 |
|---------|------|------|---------|
| `seal` | bytes | `receipt_hex` | 添加 `0x` 前缀：`"0x" + receipt_hex` |
| `recipient` | address | 请求中的 `recipient` | 直接使用，确保与 `msg.sender` 一致 |
| `nullifier` | bytes32 | `nullifier_hex` | 添加 `0x` 前缀：`"0x" + nullifier_hex` |

**重要约束**:
- `recipient` 必须等于调用合约的 `msg.sender`（即交易发送者地址）
- `nullifier` 必须未被使用过（合约会检查 `nullifiers` 映射）

---

## 完整调用流程

### 步骤 1: 准备数据

```javascript
// 1.1 准备 GitHub 用户数据
const githubData = {
 id: 12345,
 login: "test_user",
 created_at: "2020-01-01T00:00:00Z",
 public_repos: 5
};

// 1.2 准备接收地址（必须是当前钱包地址）
const recipient = "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145";

// 1.3 将数据转换为 JSON 字符串
const inputJson = JSON.stringify(githubData);
```

### 步骤 2: 调用后端生成证明

```javascript
const response = await fetch('http://localhost:3000/prove', {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify({
  input_json: inputJson,
  recipient: recipient
 })
});

const proofData = await response.json();

if (proofData.status !== "success") {
 throw new Error("Proof generation failed: " + proofData.status);
}
```

### 步骤 3: 验证返回数据

```javascript
// 验证数据格式
if (!proofData.receipt_hex || proofData.receipt_hex.length < 500) {
 throw new Error("Invalid receipt_hex format");
}

if (!proofData.journal_hex || proofData.journal_hex.length !== 128) {
 throw new Error("Invalid journal_hex format (should be 128 chars)");
}

if (!proofData.nullifier_hex || proofData.nullifier_hex.length !== 64) {
 throw new Error("Invalid nullifier_hex format (should be 64 chars)");
}

if (!proofData.image_id_hex || proofData.image_id_hex.length !== 64) {
 throw new Error("Invalid image_id_hex format (should be 64 chars)");
}
```

### 步骤 4: 准备合约调用参数

```javascript
// 4.1 处理 seal（添加 0x 前缀）
const seal = proofData.receipt_hex.startsWith("0x") 
 ? proofData.receipt_hex 
 : "0x" + proofData.receipt_hex;

// 4.2 处理 nullifier（添加 0x 前缀）
const nullifier = proofData.nullifier_hex.startsWith("0x")
 ? proofData.nullifier_hex
 : "0x" + proofData.nullifier_hex;

// 4.3 recipient 直接使用（确保与 msg.sender 一致）
const mintRecipient = recipient; // 必须是当前钱包地址
```

### 步骤 5: 调用合约 mint 方法

```javascript
// 5.1 获取合约实例
const contract = new ethers.Contract(
 contractAddress,
 ["function mint(bytes calldata seal, address recipient, bytes32 nullifier) external"],
 signer
);

// 5.2 预检查：验证 Image ID
const contractImageId = await contract.imageId();
const proofImageId = "0x" + proofData.image_id_hex;

if (contractImageId.toLowerCase() !== proofImageId.toLowerCase()) {
 throw new Error("Image ID mismatch!");
}

// 5.3 预检查：检查 nullifier 是否已使用
const nullifierUsed = await contract.nullifiers(nullifier);
if (nullifierUsed) {
 throw new Error("This proof has already been used!");
}

// 5.4 模拟交易（可选，用于提前发现错误）
try {
 await contract.mint.staticCall(seal, mintRecipient, nullifier);
} catch (simError) {
 throw new Error("Transaction will fail: " + simError.message);
}

// 5.5 估算 Gas
const gasEstimate = await contract.mint.estimateGas(seal, mintRecipient, nullifier);

// 5.6 发送交易
const tx = await contract.mint(seal, mintRecipient, nullifier, {
 gasLimit: gasEstimate * BigInt(2) // 使用 2 倍估算值作为安全边界
});

// 5.7 等待确认
const receipt = await tx.wait();

if (receipt.status === 1) {
 console.log("✅ Mint successful! TX:", receipt.hash);
} else {
 throw new Error("Transaction failed");
}
```

---

## 代码示例

### JavaScript (浏览器/Node.js)

```javascript
const ethers = require("ethers"); // 或使用 CDN: https://cdnjs.cloudflare.com/ajax/libs/ethers/6.13.2/ethers.umd.min.js

async function generateProofAndMint(contractAddress, recipient, githubData) {
 // 步骤 1: 准备数据
 const inputJson = JSON.stringify(githubData);
 
 // 步骤 2: 调用后端生成证明
 const response = await fetch('http://localhost:3000/prove', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
   input_json: inputJson,
   recipient: recipient
  })
 });
 
 const proofData = await response.json();
 
 if (proofData.status !== "success") {
  throw new Error("Proof generation failed: " + proofData.status);
 }
 
 // 步骤 3: 验证返回数据
 if (proofData.journal_hex.length !== 128) {
  throw new Error("Invalid journal_hex length");
 }
 if (proofData.nullifier_hex.length !== 64) {
  throw new Error("Invalid nullifier_hex length");
 }
 
 // 步骤 4: 准备合约参数
 const seal = "0x" + proofData.receipt_hex;
 const nullifier = "0x" + proofData.nullifier_hex;
 
 // 步骤 5: 调用合约（需要先连接钱包）
 const provider = new ethers.BrowserProvider(window.ethereum);
 const signer = await provider.getSigner();
 
 const contract = new ethers.Contract(
  contractAddress,
  ["function mint(bytes calldata seal, address recipient, bytes32 nullifier) external"],
  signer
 );
 
 // 验证 Image ID
 const contractImageId = await contract.imageId();
 const proofImageId = "0x" + proofData.image_id_hex;
 if (contractImageId.toLowerCase() !== proofImageId.toLowerCase()) {
  throw new Error("Image ID mismatch!");
 }
 
 // 检查 nullifier
 const nullifierUsed = await contract.nullifiers(nullifier);
 if (nullifierUsed) {
  throw new Error("Proof already used!");
 }
 
 // 发送交易
 const tx = await contract.mint(seal, recipient, nullifier);
 const receipt = await tx.wait();
 
 return receipt;
}

// 使用示例
const githubData = {
 id: 12345,
 login: "test_user",
 created_at: "2020-01-01T00:00:00Z",
 public_repos: 5
};

generateProofAndMint(
 "0x...", // 合约地址
 "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145", // 接收地址
 githubData
).then(receipt => {
 console.log("Mint successful!", receipt);
}).catch(error => {
 console.error("Error:", error);
});
```

### Python

```python
import requests
import json
from web3 import Web3

def generate_proof_and_mint(contract_address, recipient, github_data):
  # 步骤 1: 准备数据
  input_json = json.dumps(github_data)
  
  # 步骤 2: 调用后端生成证明
  response = requests.post(
    'http://localhost:3000/prove',
    json={
      'input_json': input_json,
      'recipient': recipient
    },
    headers={'Content-Type': 'application/json'}
  )
  
  proof_data = response.json()
  
  if proof_data['status'] != 'success':
    raise Exception(f"Proof generation failed: {proof_data['status']}")
  
  # 步骤 3: 验证返回数据
  if len(proof_data['journal_hex']) != 128:
    raise Exception("Invalid journal_hex length")
  if len(proof_data['nullifier_hex']) != 64:
    raise Exception("Invalid nullifier_hex length")
  
  # 步骤 4: 准备合约参数
  seal = '0x' + proof_data['receipt_hex']
  nullifier = '0x' + proof_data['nullifier_hex']
  
  # 步骤 5: 调用合约（需要先连接 Web3）
  w3 = Web3(Web3.HTTPProvider('https://sepolia.infura.io/v3/YOUR_PROJECT_ID'))
  contract = w3.eth.contract(address=contract_address, abi=[...]) # 需要提供 ABI
  
  # 验证 Image ID
  contract_image_id = contract.functions.imageId().call()
  proof_image_id = '0x' + proof_data['image_id_hex']
  if contract_image_id.lower() != proof_image_id.lower():
    raise Exception("Image ID mismatch!")
  
  # 检查 nullifier
  nullifier_used = contract.functions.nullifiers(nullifier).call()
  if nullifier_used:
    raise Exception("Proof already used!")
  
  # 发送交易
  tx_hash = contract.functions.mint(
    seal.encode('utf-8') if isinstance(seal, str) else seal,
    recipient,
    nullifier
  ).transact({'from': recipient})
  
  receipt = w3.eth.wait_for_transaction_receipt(tx_hash)
  return receipt

# 使用示例
github_data = {
  'id': 12345,
  'login': 'test_user',
  'created_at': '2020-01-01T00:00:00Z',
  'public_repos': 5
}

try:
  receipt = generate_proof_and_mint(
    '0x...', # 合约地址
    '0x534C283D6339183d20c2e7f0fd6522d9e6CD5145', # 接收地址
    github_data
  )
  print("Mint successful!", receipt)
except Exception as e:
  print("Error:", e)
```

### curl (命令行)

```bash
# 步骤 1: 生成证明
curl -X POST http://localhost:3000/prove \
 -H "Content-Type: application/json" \
 -d '{
  "input_json": "{\"id\":12345,\"login\":\"test_user\",\"created_at\":\"2020-01-01T00:00:00Z\",\"public_repos\":5}",
  "recipient": "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145"
 }' > proof_response.json

# 步骤 2: 提取数据（需要 jq）
RECEIPT_HEX=$(jq -r '.receipt_hex' proof_response.json)
NULLIFIER_HEX=$(jq -r '.nullifier_hex' proof_response.json)
IMAGE_ID_HEX=$(jq -r '.image_id_hex' proof_response.json)

# 步骤 3: 调用合约（需要使用 cast 或其他工具）
# 注意：需要先连接钱包并部署合约
cast send <CONTRACT_ADDRESS> \
 "mint(bytes,address,bytes32)" \
 "0x${RECEIPT_HEX}" \
 "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145" \
 "0x${NULLIFIER_HEX}" \
 --rpc-url <RPC_URL> \
 --private-key <PRIVATE_KEY>
```

---

## 错误处理

### 常见错误及解决方案

#### 1. Proof 生成失败

**错误信息**: `status !== "success"`

**可能原因**:
- JSON 格式错误
- 缺少必需字段
- recipient 地址格式错误

**解决方案**:
```javascript
// 验证 JSON 格式
try {
 JSON.parse(inputJson);
} catch (e) {
 console.error("Invalid JSON:", e);
}

// 验证必需字段
const data = JSON.parse(inputJson);
if (!data.id || !data.login || !data.created_at || !data.public_repos) {
 throw new Error("Missing required fields");
}

// 验证地址格式
if (!ethers.isAddress(recipient)) {
 throw new Error("Invalid recipient address");
}
```

#### 2. Image ID 不匹配

**错误信息**: `Image ID mismatch!`

**原因**: 合约部署时使用的 Image ID 与证明的 Image ID 不一致

**解决方案**:
```javascript
// 获取合约 Image ID
const contractImageId = await contract.imageId();

// 获取证明 Image ID
const proofImageId = "0x" + proofData.image_id_hex;

// 比较（不区分大小写）
if (contractImageId.toLowerCase() !== proofImageId.toLowerCase()) {
 throw new Error(`Image ID mismatch! Contract: ${contractImageId}, Proof: ${proofImageId}`);
}
```

#### 3. Nullifier 已被使用

**错误信息**: `This proof has already been used!`

**原因**: 同一个 nullifier 不能重复使用

**解决方案**:
```javascript
// 在 mint 前检查
const nullifierUsed = await contract.nullifiers(nullifier);
if (nullifierUsed) {
 throw new Error("This proof has already been used. Please generate a new proof.");
}
```

#### 4. Recipient 地址不匹配

**错误信息**: `Proof must be for the transaction sender`

**原因**: 合约要求 `recipient` 必须等于 `msg.sender`

**解决方案**:
```javascript
// 确保 recipient 是当前钱包地址
const currentAddress = await signer.getAddress();
if (recipient.toLowerCase() !== currentAddress.toLowerCase()) {
 throw new Error("Recipient must be the current wallet address");
}
```

#### 5. 证明验证失败

**错误信息**: `execution reverted 0xe4ea6542...`

**原因**: Seal、Image ID 或 Journal digest 不匹配

**解决方案**:
```javascript
// 验证 seal 格式
if (!seal.startsWith("0x") || seal.length < 500) {
 throw new Error("Invalid seal format");
}

// 验证 journal 编码
const expectedJournal = ethers.AbiCoder.defaultAbiCoder().encode(
 ["address", "bytes32"],
 [recipient, nullifier]
);
const expectedDigest = ethers.sha256(expectedJournal);

// 比较 digest（合约内部会计算 sha256(journal)）
console.log("Expected journal digest:", expectedDigest);
```

---

## 常见问题

### Q1: 如何确认后端服务正在运行？

**A**: 检查后端服务是否响应：

```bash
curl http://localhost:3000/
```

应该返回: `GhostLink Groth16 Prover Service`

### Q2: Journal 格式如何验证？

**A**: 使用以下代码验证：

```javascript
const recipient = "0x534C283D6339183d20c2e7f0fd6522d9e6CD5145";
const nullifier = "0x" + proofData.nullifier_hex;

// 计算期望的 journal
const expectedJournal = ethers.AbiCoder.defaultAbiCoder().encode(
 ["address", "bytes32"],
 [recipient, nullifier]
);

// 比较
const backendJournal = "0x" + proofData.journal_hex;
if (expectedJournal.toLowerCase() !== backendJournal.toLowerCase()) {
 console.error("Journal mismatch!");
 console.error("Expected:", expectedJournal);
 console.error("Backend: ", backendJournal);
}
```

### Q3: Seal 长度应该是多少？

**A**: Groth16 seal 通常为 256-300 字节（512-600 个十六进制字符，包含 0x 前缀）。

```javascript
const sealByteLength = (seal.length - 2) / 2; // 减去 "0x"
console.log("Seal byte length:", sealByteLength, "(should be 256-300)");
```

### Q4: 如何获取合约的 Image ID？

**A**: 调用合约的 `imageId()` 方法：

```javascript
const contractImageId = await contract.imageId();
console.log("Contract Image ID:", contractImageId);
```

### Q5: 如何检查 nullifier 是否已使用？

**A**: 调用合约的 `nullifiers(bytes32)` 方法：

```javascript
const nullifierUsed = await contract.nullifiers(nullifier);
if (nullifierUsed) {
 console.log("Nullifier already used!");
} else {
 console.log("Nullifier available!");
}
```

### Q6: 合约部署需要哪些参数？

**A**: 部署合约需要两个参数：

1. **Verifier 地址**: RISC Zero 官方预编译合约地址
 - Sepolia Router: `0x925d8331ddc0a1F0d96E68CF073DFE1d92b69187`
 - Mainnet Router: `0x8EaB2D97Dfce405A1692a21b3ff3A172d593D319`

2. **Image ID**: Guest 程序的 Image ID（从后端启动日志获取）

### Q7: 如何调试交易失败？

**A**: 使用 `staticCall` 模拟交易：

```javascript
try {
 await contract.mint.staticCall(seal, recipient, nullifier);
 console.log("✅ Transaction simulation passed");
} catch (error) {
 console.error("❌ Transaction will fail:", error);
 // 检查错误代码
 if (error.data && error.data.startsWith("0xe4ea6542")) {
  console.error("Proof verification failed!");
 }
}
```

---

## 参数映射总结表

| 后端返回字段 | 格式 | 合约 mint 参数 | 转换方式 |
|------------|------|--------------|---------|
| `receipt_hex` | 十六进制字符串（无 0x） | `seal` (bytes) | `"0x" + receipt_hex` |
| `nullifier_hex` | 十六进制字符串（无 0x，64 字符） | `nullifier` (bytes32) | `"0x" + nullifier_hex` |
| `recipient` (请求参数) | 以太坊地址（42 字符） | `recipient` (address) | 直接使用 |
| `journal_hex` | 十六进制字符串（无 0x，128 字符） | - | 用于验证，不直接传入 |
| `image_id_hex` | 十六进制字符串（无 0x，64 字符） | - | 用于验证合约 Image ID |

---

## 联系支持

如有问题，请提供以下信息：

1. 后端服务日志
2. 请求和响应的完整数据
3. 合约地址和网络
4. 错误信息和堆栈跟踪

---

**文档版本**: 1.0 
**最后更新**: 2024

